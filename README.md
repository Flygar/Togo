## NOTE
>引用类型：指针(pointer),切片(slice),字典(map),管道(channel),接口(interface)  
>值类型：数组(array)

**数组(array)**  
>1. 值类型; 
>2. 可以通过 new() 来创建: `var arr1 = new([5]int)`

**切片(slice)**

>1. 引用类型;可以通过make来创建长度为0，容量为5的切片: `s := make([]string, 0, 5)`
>2. go中切片比数组常见,切片本身就是一个引用类型(指针),所以不要用指针指向 slice
>3. 把一个大数组传递给函数会消耗很多内存。有两种方法可以避免这种现象：传递数组的指针，使用数组的切片
>4. 注意 slice 和数组在声明时的区别：声明数组时，方括号内写明了数组的长度或使用 ... 自动计算长度，而声明 slice 时，方括号内没有任何字符。
>5. 切片并不存储任何数据，它只是描述了底层数组中的一段，更改切片的元素会修改其底层数组中对应的元素(与它共享底层数组的切片都会观测到这些修改)。

**字典(map)**

>1. 引用类型;声明用make; ` m := make(map[string]int)`; 省略了 map 的长度，map 是可以动态增长的。
>2. 通过 key 在 map 中寻找值是很快的，比线性查找快得多，但是仍然比从数组和切片的索引中直接读取要慢 100 倍；所以如果你很在乎性能的话还是建议用切片来解决问题。
>3. 注意 map 不是按照 key 的顺序排列的，也不是按照 value 的序排列的。（无序排列）
>4. map 非线程安全 当并行访问一个共享的 map 类型的数据，map 数据将会出错

**range**

**new&make**
- 相同点：

    均用于在堆上分配内存；
    
    第一个参数都是类型(T),而不是值;

- 不同点：

    new返回指针(所以对于值类型: 数组,结构体;可以用new(T)来分配类型 T 的零值并返回其地址，也就是指向类型 T 的指针);仅分配空间;
    
    make(T) 返回类型 T (传入的T如果是引用类型，那么返回的也是引用类型) (所以对于引用类型(指针): Slice,Map,Channel;可以用make(T)来返回类型 T 并初始化);在堆上分配内存空间并初始化;
    

**指针**
>1. 带指针(或值)参数的函数必须接受一个指针(或值);
>1. 而以指针(或值)为接收者的方法被调用时，接收者既能为值又能为指针 
>2. 值类型的变量的值存储在栈中
>3. 引用传递：slices，maps，channel；被引用的变量会存储在堆中，以便进行垃圾回收，且比栈拥有更大的内存空间。
>4. 字符串：值类型，且值不可改变
>4. range:值拷贝
>4. 数组：值拷贝
>4. 切片：本质就是指向数组的指针，引用传递；所以不需要指针指向切片
>4. 为保证内存安全，golang中不允许做指针运算（与c的区别）
>4. 对一个空指针的反向引用是不合法的，并且会使程序崩溃
>4. 高级应用：你可以传递一个变量的引用（如函数的参数），这样不会传递变量的拷贝。

**struct**

&struct1{a, b, c} 是一种简写，底层仍然会调用 new ()
表达式 new(Type) 和 &Type{} 是等价的。&Type底层仍会调用new()

**栈和堆**

栈: 主要是用来执行程序;后进先出(defer也是后进先出), 分配的空间是临时的, 在函数退出后将被系统释放, 不会造成内存泄露; 因为栈的空间小所以在栈上不能获得大量的内存块, 一般最大也就不到 10M 堆是在整个进程的未分配空间中分配的内存; 函数内部的其他变量和常量都在栈上。
堆: 主要用来存放对象。堆上可以分配大量的内存, 只要你的机器吃得消; 一般来说, 由new和malloc分配的内存都在堆上, 全局变量也在堆上。
